import decimal
import random
from datetime import datetime, timedelta
from random import randint
from sqlalchemy import  Column, Integer, String, Float, JSON, DateTime, Boolean, ForeignKey,ARRAY, DECIMAL
from sqlalchemy.orm import declarative_base
from sqlalchemy.future import select
from sqlalchemy import update
from sqlalchemy.orm import relationship
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from sqlalchemy.dialects.postgresql import array
import copy
Base = declarative_base()
DB_URL = 'postgresql+asyncpg://myuser:XGaaNySprD3@51.20.105.5/mydatabase'
import jwt
import uuid
tg_Bot_link = 'https://t.me/FrogTONBOT'
class FrogTON(Base):
    __abstract__ = True

    def to_dict(self):
        return {
            c.name: (
                getattr(self, c.name).__str__() if isinstance(getattr(self, c.name), datetime)
                else str(getattr(self, c.name)) if isinstance(getattr(self, c.name), Decimal)
                else getattr(self, c.name)
            )
            for c in self.__table__.columns if c.name != 'password'
        }

class Users_FrogTON( FrogTON):
    __tablename__ = 'Users_FrogTON'
    id = Column(Integer, primary_key=True)
    password = Column(String)
    sign = Column(String)
    telegram_id = Column(Integer)
    name = Column(String)
    username = Column(String)
    invited_by = Column(Integer)
    invitation_code= Column(Integer)
    invited_users = Column(ARRAY(Integer), default=[])
    real_balance = Column(DECIMAL, default=110)
    balances = Column(JSON, default=  {'green' : {}, 'yellow': {}, 'red':{} })
    amount_of_money_withdrawed = Column(Float, default=0)
    amount_of_money_topupped= Column(Float, default=0)
    profit = Column(DECIMAL, default=0)
    created_at  = Column(DateTime)


class Purchases_FrogTON(FrogTON):
    __tablename__='Purchases_FrogTON'
    id = Column(Integer, primary_key=True)
    was_purchased_by_user_id = Column(Integer)
    good_id = Column(Integer)
    profit_given = Column(Boolean, default=False)
    created_at  = Column(DateTime)



class  Payouts_FrogTON(FrogTON):
    __tablename__ = 'Payouts_FrogTON'
    id = Column(Integer, primary_key=True)
    by_user_id = Column(Integer)
    ton_amount = Column(DECIMAL)
    order_id = Column(String)
    is_paid = Column(Boolean, default=False)
    created_at = Column(DateTime)
    is_approved = Column(Boolean, default=None)
    address = Column(String)


class Goods_FrogTON(FrogTON):
    __tablename__='Goods_FrogTON'
    id = Column(Integer,primary_key=True)
    name = Column(String)
    price_in_ton = Column(Float)
    income = Column(Float)


class Payments_FrogTON(FrogTON):
    __tablename__ = 'payments'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer)
    amount = Column(Float)

    uuid = Column(String)
    description = Column(String)
    order_id = Column(String)
    status = Column(String)
    created_at = Column(DateTime)

    address = Column(String)

    url = Column(String)




engine = create_async_engine(DB_URL, echo=True)

# –°–æ–∑–¥–∞–Ω–∏–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Ñ–∞–±—Ä–∏–∫–∏ —Å–µ—Å—Å–∏–π
async_session = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)


async def add_to_invited_users(session, user_id, new_value):
    await session.execute(
        update(Users_FrogTON)
        .where(Users_FrogTON.id == user_id)
        .values(invited_users=array.append(Users_FrogTON.invited_users, new_value))
    )
    await session.commit()

async def remove_from_invited_users(session, user_id, value_to_remove):
    await session.execute(
        update(Users_FrogTON)
        .where(Users_FrogTON.id == user_id)
        .values(invited_users=array.remove(Users_FrogTON.invited_users, value_to_remove))
    )
    await session.commit()


async def generate_unique_uuid(is_payout=False):
    async with async_session() as session:

        while True:
            new_uuid = uuid.uuid4()

            if is_payout:
                # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ç–∞–∫–æ–π UUID –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è Payouts
                stmt = select(Payouts_FrogTON).filter(Payouts_FrogTON.order_id == str(new_uuid))
                result = await session.execute(stmt)
                existing_record = result.scalar()
                if not existing_record:
                    # –ï—Å–ª–∏ —Ç–∞–∫–æ–≥–æ UUID –µ—â–µ –Ω–µ—Ç –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ
                    return str(new_uuid)
            else:
                # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ç–∞–∫–æ–π UUID –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è Payments
                stmt = select(Payments_FrogTON).filter(Payments_FrogTON.order_id == str(new_uuid))
                result = await session.execute(stmt)
                existing_record = result.scalar()
                if not existing_record:
                    # –ï—Å–ª–∏ —Ç–∞–∫–æ–≥–æ UUID –µ—â–µ –Ω–µ—Ç –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ
                    return str(new_uuid)


async def succesful_payment(uuid, status):
    try:
        async with async_session() as session:
            async with session.begin():
                query = select(Payments_FrogTON).filter(Payments_FrogTON.uuid == uuid)
                result = await  session.execute(query)
                existing_record = result.scalar()
                update_payment_query = (
                    update(Payments_FrogTON)
                    .where(Payments_FrogTON.uuid == uuid)
                    .values(status = status)
                )
                await session.execute(update_payment_query)
                if status =='paid':
                    query_for_user = select(Users_FrogTON).filter(Users_FrogTON.id == existing_record.user_id)
                    result_for_user = await session.execute(query_for_user)
                    user = result_for_user.scalar()

                    if user.invited_by:
                        user_who_invited = await  find_user_by_id(user.invited_by)
                        update_user_who_invited_query = (
                            update(Users_FrogTON)
                            .where(Users_FrogTON.id == user_who_invited.id)
                            .values(real_balance=user_who_invited.real_balance+Decimal(str(0.05)))
                        )
                        await session.execute(update_user_who_invited_query)
                        await remove_from_invited_users(session, user_who_invited.id, user.id)
                        update_user_query = (
                            update(Users_FrogTON).where(Users_FrogTON.id == user.id)
                            .values(real_balance=user.real_balance + existing_record.amount, invited_by=0)
                        )
                        await session.execute(update_user_query)
                    user.real_balance += existing_record.amount
                    return user
    except Exception as ex:
        print(ex)


async def add_payment(user_id, amount,  uuid, status  , order_id , address , url ):
    try:
        new_payment = Payments_FrogTON(
            user_id=user_id,
            amount=amount,
            uuid=uuid,
            order_id =order_id,
            status =status,
            created_at =datetime.now(),
            address=address,
            url=url

        )
        async with async_session() as session:
            async with session.begin():
                session.add(new_payment)
        return new_payment


    except Exception as ex:
        print(ex)
        return False

async def add_purchase(user_id, good_id):
    try:
        new_purchase = Purchases_FrogTON(
            was_purchased_by_user_id = user_id,
            good_id = good_id,
            created_at = datetime.now()


        )
        async with async_session() as session:
            async with session.begin():
                session.add(new_purchase)
        return new_purchase
    except Exception as ex:
        print(ex)
async def add_payout(user_id, amount, address):
    try:
        """__tablename__ = 'Payouts_FrogTON'
        id = Column(Integer, primary_key=True)
        by_user_id = Column(Integer)
        ton_amount = Column(DECIMAL)
        is_paid = Column(Boolean)
        created_at = Column(DateTime)
        is_approved = Column(Boolean)
        address = Column(String)"""
        user = await find_user_by_id(user_id)
        if user.real_balance:
            uniq_id = await generate_unique_uuid(True)
            new_payout = Payouts_FrogTON(
by_user_id = user_id, ton_amount=amount, order_id=uniq_id, address=address
        )
            async with async_session() as session:
                async with session.begin():
                    session.add(new_payout)
                    update_user_query= (update(Users_FrogTON)
                                        .where(Users_FrogTON.id == user_id)
                                        .values(real_balance=user.real_balance-Decimal(str(amount)))

                                        )
                    await session.execute(update_user_query)
            return new_payout, user
    except Exception as ex:
        print(ex)

async def find_payout_by_id(payout_id):
    try:
        async with async_session() as session:
            payout_query = select(Payouts_FrogTON).where(Payouts_FrogTON.id == payout_id)
            result = await  session.execute(payout_query)
            payout = result[0]
            return payout
    except Exception as ex:
        print(ex)

async def make_payout(payout_id):
    try:
        async with async_session() as session:
            payout =await find_payout_by_id(payout_id)
            update_payout_query = (
                update(Payouts_FrogTON)
                .where(Payouts_FrogTON.id == payout_id)
                .values(is_approved=True, is_paid=True)
            )
            result = await  session.execute(update_payout_query)


        return payout


    except Exception as ex:
        print(ex)

async def decline_payout_handl(payout_id):
    try:
        async with async_session() as session:
            payout =await find_payout_by_id(payout_id)
            update_payout_query = (
                update(Payouts_FrogTON)
                .where(Payouts_FrogTON.id == payout_id)
                .values(is_approved=False)
            )
            user = await find_user_by_id(payout.by_user_id )
            update_user_query = (
                update(Users_FrogTON)
                .where(Users_FrogTON.id == user.id)
                .values(real_balance=user.real_balance +  Decimal(str(payout.ton_amount)))
            )
            await  session.execute(update_user_query)
            print(user.to_dict())
            result = await  session.execute(update_payout_query)




    except Exception as ex:
        print(ex)

async  def find_user_by_invit_code(invit_code):
    try:
        async with async_session() as session:
            query = select(Users_FrogTON).where(Users_FrogTON.invitation_code == invit_code)
            result = await session.execute(query)
            return result.scalar()
    except Exception as ex:
        print(ex)

async def add_user(telegram_id, name, username, created_at, invit_code):
    try:
        password = str(uuid.uuid4())
        user = await find_user_by_invit_code(invit_code)
        if not user:
            new_user = Users_FrogTON(
                telegram_id=telegram_id,
                name=name,
                username=username,
                created_at=created_at,
                password=password,
                sign=jwt.encode({'id': telegram_id, "password": password}, 'secret_key'),
                invitation_code=random.randint(100, 2147483647),

            )
        else:
            new_user = Users_FrogTON(
            telegram_id=telegram_id,
            name=name,
            username=username,
            created_at=created_at,
            password=password,
            sign=jwt.encode({'id':telegram_id, "password":password}, 'secret_key'),
            invitation_code = random.randint(100, 2147483647),
            invited_by = user.id
        )

        # –°–æ–∑–¥–∞–Ω–∏–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Å–µ—Å—Å–∏–∏ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        async with async_session() as session:
            async with session.begin():
                session.add(new_user)
        print(new_user.to_dict(), 'sosi')

        return new_user
    except Exception as ex:
        print(ex, 'EEEEEEEE')

async def get_users():
    try:
        async with async_session() as session:
            result = await session.execute(select(Users_FrogTON))
            users = result.scalars().all()
            for user in users:
                print(user.name, user.username)

    except Exception as ex:
        print(ex)

async def find_good_by_id(id):
    try:
        async with async_session() as session:
            async with session.begin():
                query = select(Goods_FrogTON).where(Goods_FrogTON.id==id)
                result = await  session.execute(query)
                good = result[0]
                return good
    except Exception as ex:
        print(ex)
from decimal import Decimal, getcontext
getcontext().prec = 10


async def buy_frog_by_user(user_id, frog_id):
    try:
        async with async_session() as session:
            async with session.begin():
                query_for_good = select(Goods_FrogTON).where(Goods_FrogTON.id == frog_id)
                result = await  session.execute(query_for_good)
                good = result.scalar()
                query_for_user = select(Users_FrogTON).where(Users_FrogTON.id == user_id)
                result = await session.execute(query_for_user)
                user = result.scalar()

                if user.balances[good.name] !={}:
                    return 'you already have this frog'
                if (user.real_balance >= good.price_in_ton):

                    purchase = await add_purchase(user.id, good.id)
                    print(purchase, 'purchu')
                    if not purchase:
                        return 'error'
                    user.balances[good.name] = purchase.to_dict()
                    float_to_decimal = Decimal(str(good.price_in_ton))
                    update_user_query = (
                        update(Users_FrogTON)
                        .where(Users_FrogTON.id == user.id)
                        .values(real_balance=user.real_balance - float_to_decimal, balances = user.balances)
                    )
                    await session.execute(update_user_query)


                    query_for_user = select(Users_FrogTON).where(Users_FrogTON.id == user_id)
                    result = await session.execute(query_for_user)
                    user = result.scalars().all()[0]
                    print(user)
                    return user
                return 'not enough money'
    except Exception as ex:
        print(ex)
async def find_user_by_id(id):
    try:
        async with async_session() as session:
            async with session.begin():
                query = select(Users_FrogTON).where(Users_FrogTON.id == id)
                result = await session.execute(query)
                users = result.scalars().all()
                return users[0]
    except Exception as e:
        print(f"An error occurred: {e}")
        return []
async def find_user_by_telegram_id(telegram_id):
    try:
        async with async_session() as session:
            async with session.begin():
                query = select(Users_FrogTON).where(Users_FrogTON.telegram_id == telegram_id)
                result = await session.execute(query)
                users = result.scalars().all()
                print(users[0].to_dict())
                return users[0]
    except Exception as e:
        print(f"An error occurred: {e}")
        return []

async def add_frogs():
    try:
        green_frog = Goods_FrogTON(
            name='green',
            price_in_ton=0.2,
            income = 0.35

        )
        yellow_frog = Goods_FrogTON(
            name='yellow',
            price_in_ton= 1,
            income=1.5
        )
        red_frog = Goods_FrogTON(
            name='red',
            price_in_ton =3,
            income=4.75
        )
        async with async_session() as session:
            async with session.begin():
                session.add_all([green_frog, yellow_frog, red_frog])

    except Exception as ex:
        print(ex)


async def drop_all_tables():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
async def create_tables():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
import asyncio
async def prepare_all():
    await drop_all_tables()
    await create_tables()
    await add_frogs()

"asyncio.run(prepare_all())"


""" ss Worker(Base):
    __tablename__ = 'workers'
    service_id = Column(Integer, default=randint(100000000, 999999999))
    telegram_id = Column(Integer, primary_key=True)
    name = Column(String)
    profit = Column(Float, default=0.0)
    profit_quantity = Column(Integer, default=0)
    balance = Column(Float, default=0.0)
    warnings = Column(Integer, default=0)
    payment_method = Column(String, default='Crypto USDT')
    created_at = Column(DateTime, default=datetime.utcnow)
    mammonts = Column(String, default='')
    invited_worker = Column(String, default='')
    token = Column(String)
    token_for_escort_bot = Column(String)
    additional_models = Column(JSON)
    mammonts_from_escort = Column(String, default='')
    children = relationship("Mammoth", back_populates="parent")

class MammothFromEscort(Base):
    __tablename__ = 'mammonths_from_escort'
    first_name = Column(String)
    telegram_id = Column(Integer, primary_key=True)
    service_id = Column(Integer)
    balance = Column(Float, default=0.0)
    was_using_support = Column(Boolean, default=False)

class Mammoth(Base):
    __tablename__ = 'mammonths'
    first_name = Column(String)
    telegram_id = Column(Integer, primary_key=True)
    service_id = Column(Integer)
    balance = Column(Float, default=0.0)
    on_output = Column(Float, default=0.0)
    cryptoportfolio = Column(JSON, default={'btc': 0.0, 'eth': 0.0,'ltc':0.0})
    succesful_deals = Column(Integer, default=0)
    deals = Column(Integer, default=0)
    luck = Column(Integer, default=50)
    min_input_output_amount_value = Column(Integer, default=2000)
    created_at = Column(DateTime, default=datetime.now())
    belongs_to_worker = Column(Integer, ForeignKey('workers.telegram_id'))
    profit = Column(Float, default=0.0)
    was_using_support = Column(Boolean, default=False)

    parent = relationship("Worker", back_populates="children")
class Futures(Base):
    __tablename__ = 'futures'
    id = Column(Integer, primary_key=True)
    message_id = Column(Integer)
    chat_id = Column(Integer)
    user_id = Column(Integer)
    cryptosymbol = Column(String)
    pool = Column(Float)
    is_increase = Column(Boolean)
    start_price = Column(Float)

class Withdraws(Base):
    __tablename__ = 'withdraws'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer)
    card = Column(Integer)
    amount = Column(Float)

class Payouts(Base):
    __tablename__ = 'payouts'
    order_id = Column(Integer, primary_key=True)
    worker_id = Column(Integer)
    currency = Column(String, default='RUB')
    to_currency = Column(String, default='USDT')
    amount = Column(Float)
    address = Column(String)
    course_source = Column(String, default='Binance')
    is_subtract = Column(Boolean, default=False)
    network = Column(String, default='TRON')

class MammonthTopUpWithCrypto(Base):
    __tablename__ = 'mammonth_top_up_with_crypto'
    order_id = Column(String)
    mammonth_id = Column(Integer)
    amount = Column(Float)
    created_at = Column(DateTime, default=datetime.now())
    cryptomus_link = Column(String)
    uuid = Column(String, primary_key=True)


class Sluts(Base):
    __tablename__ = 'sluts'
    slut_id = Column(Integer, primary_key=True)
    name = Column(String)
    age = Column(Integer)
    prices = Column(JSON)
    description = Column(String)
    services = Column(String)

class ReviewsAboutSluts(Base):
    __tablename__ = 'reviews_about_sluts'
    review_id = Column(Integer, primary_key=True)
    slut_id = Column(Integer)
    name = Column(String)
    date = Column(DateTime)
    text = Column(String) """
# slut1 = Sluts(name = '–†–∏–∞–Ω–∞', age = 24, description = '''
# –ö–æ—Ä–æ–ª–µ–≤–∞ –º–∏–Ω–µ—Ç–∞, –≥–æ—Ç–æ–≤–∞ —É–±–ª–∞–∂–∏—Ç—å —Ç–µ–±—è –¥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è —É–º–æ–ø–æ–º—Ä–∞—á–µ–Ω–∏—è, –∞ —Ç–∞–∫–∂–µ –∑–∞—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–±—è –ø–æ–¥—á–∏–Ω—è—Ç—å—Å—è. –õ—é–±–ª—é –ø–æ–∂—ë—Å—Ç—á–µ))
# ''', services = '''–ú–ë–†, –æ–∫–æ–Ω—á–∞–Ω–∏–µ –≤ —Ä–æ—Ç, –ª–µ–≥–∫–∞—è –¥–æ–º–∏–Ω–∞—Ü–∏—è, —Å–∞–¥–æ-–º–∞–∑–æ''', prices={'–ß–∞—Å':4600, "2 —á–∞—Å–∞":8500, '–ù–æ—á—å':21100 })
#
# slut2 = Sluts(name = '–ù–∞—Ç–∞—à–µ–Ω—å–∫–∞', age = 26, description = '''
# –ñ–∞—Ä–∫–∞—è –º–∞–ª—ã—à–∫–∞ —Å –æ—á–µ–Ω—å –∞–ø–ø–µ—Ç–∏—Ç–Ω—ã–º–∏ —Ñ–æ—Ä–º–∞–º–∏ –∏ —Å–ª–∞–¥–∫–∏–º–∏ –¥—ã—Ä–æ—á–∫–∞–º–∏. –ü–æ–∫–∞–∑—ã–≤–∞—é –≤—Å—é —Ä–æ—Å–∫–æ—à—Å—Ç—å —Å–≤–æ–µ–≥–æ —Ç–µ–ª–∞ –∏ —Å —É–¥–æ–≤–æ–ª—å—Å—Ç–≤–∏–µ–º –≥–æ—Ç–æ–≤–∞ –¥–æ—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–±–µ –Ω–µ–∑–∞–±—ã–≤–∞–µ–º—ã–µ —ç–º–æ—Ü–∏–∏üî•
# ''', services = '''–ö—É–Ω–∏–ª–∏–Ω–≥—É—Å, —Å–µ–∫—Å—É–∞–ª—å–Ω—ã–µ –∫–æ—Å—Ç—é–º—ã, —Å—Ç—Ä–∏–ø—Ç–∏–∑''', prices={'–ß–∞—Å':5300, "2 —á–∞—Å–∞":9200, '–ù–æ—á—å':21000 })
#
# slut3 = Sluts(name = '–ö—Ä–∏—Å—Ç–∏–Ω–∞', age = 22, description = '''
# –ú–µ–Ω—è –º–æ–∂–Ω–æ –æ—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏–∑–æ–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —Å–ª–æ–≤–∞–º–∏: —è –ø–æ—Ö–æ—Ç–ª–∏–≤–∞—è –¥–µ–≤—á–æ–Ω–∫–∞ –∏ —Å–æ–≥–ª–∞—Å–Ω–∞ –Ω–∞ –ª—é–±—ã–µ —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—ã –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –æ–±–æ—é–¥–Ω–æ–≥–æ –æ—Ä–≥–∞–∑–º–∞ –≤ –ø–æ—Å—Ç–µ–ª–∏))
# ''', services = '''–ú–ë–†, –∞–Ω–∞–ª, —Å–µ–∫—Å-–∏–≥—Ä—É—à–∫–∏, —Ä–æ–ª–µ–≤—ã–µ –∏–≥—Ä—ã''', prices={'–ß–∞—Å':4500, "2 —á–∞—Å–∞":8000, '–ù–æ—á—å':12600 })
#
# slut4 = Sluts(name = '–ù–∞—Å—Ç—è', age = 24, description = '''
# –≠—Ç–∞ –¥–µ–≤–æ—á–∫–∞ –æ–±–ª–∞–¥–∞–µ—Ç —É–ø—Ä—É–≥–æ–π –ø–æ–ø–∫–æ–π –∏ –∑–∞–≤–æ–¥–Ω—ã–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–æ–º, —Ç–æ, —á—Ç–æ –Ω—É–∂–Ω–æ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∫–∞–∂–¥–æ–º—É!
# ''', services = '''–ú–ë–†, –∞–Ω–∞–ª, —Ñ–∏–Ω–≥–µ—Ä–∏–Ω–≥''', prices={'–ß–∞—Å':6500, "2 —á–∞—Å–∞":12000, '–ù–æ—á—å':22300 })
#
# slut5 = Sluts(name = '–í–∏–∫–∞', age = 24, description = '''
# –§–∏–Ω–≥–µ—Ä–∏–Ω–≥, –±–æ–Ω–¥–∞–∂, –æ–∫–æ–Ω—á–∞–Ω–∏–µ –Ω–∞ –≥—Ä—É–¥—å''', services = '''–§–∏–Ω–≥–µ—Ä–∏–Ω–≥, –±–æ–Ω–¥–∞–∂, –æ–∫–æ–Ω—á–∞–Ω–∏–µ –Ω–∞ –≥—Ä—É–¥—å''', prices={'–ß–∞—Å':4500, "2 —á–∞—Å–∞":8600, '–ù–æ—á—å':18000 })
#
# slut6 = Sluts(name = '–ù–∞—Ç–∞—à–∞', age = 27, description = '''
# –ì–æ—Ä—è—á–∞—è –∏ —Å–µ–∫—Å—É–∞–ª—å–Ω–∞—è –¥–µ–≤–æ—á–∫–∞, —Å–ø–æ—Å–æ–±–Ω–∞—è —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç—å –∫–∞–∂–¥–æ–≥–æ –º—É–∂—á–∏–Ω—É —Å–≤–æ–∏–º–∏ —É—Å–ª—É–≥–∞–º–∏)''', services = '''–ê–Ω–∞–ª, —Å–µ–∫—Å-–∏–≥—Ä—É—à–∫–∏, –ú–ë–†, –æ–∫–æ–Ω—á–∞–Ω–∏–µ –≤ —Ä–æ—Ç,
# –æ–∫–æ–Ω—á–∞–Ω–∏–µ –Ω–∞ –≥—Ä—É–¥—å''', prices={'–ß–∞—Å':8500, "2 —á–∞—Å–∞":16100, '–ù–æ—á—å':56400 })
#
# slut7 = Sluts(name = '–í–∞–ª–µ—Ä–∏—è', age = 24, description = '''
# –®–∏—Ä–æ–∫–æ –∏–∑–≤–µ—Å—Ç–Ω–∞—è –≤ —É–∑–∫–∏—Ö –∫—Ä—É–≥–∞—Ö –í–∞–ª–µ—Ä–∏—è —Å–≤–æ–¥–∏—Ç —Å —É–º–∞ –Ω–∞—à–∏—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ —É–∂–µ –Ω–∞ –ø—Ä–æ—Ç—è–∂–µ–Ω–∏–∏ 2 –ª–µ—Ç. –ü–æ—Ä–∞ –ø–µ—Ä–µ—Å—Ç–∞—Ç—å –æ—Ç–∫–ª–∞–¥—ã–≤–∞—Ç—å –Ω–∞ –ø–æ—Ç–æ–º, –≤–æ–∑—å–º–∏ –≤—Å–µ —á—Ç–æ —Ö–æ—á–µ—à—å –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å!
# ''', prices={'–ß–∞—Å':12800, "2 —á–∞—Å–∞":24200, '–ù–æ—á—å':78600 }, services='''–ê–Ω–∞–ª, –ú–ë–†, –æ–∫–æ–Ω—á–∞–Ω–∏–µ –≤ —Ä–æ—Ç, –æ–∫–æ—á–∞–Ω–∏–µ –Ω–∞ –≥—Ä—É–¥—å, —Ñ–∏–Ω–≥–µ—Ä–∏–Ω–≥, –∫—É–Ω–∏–ª–∏–Ω–≥—É—Å, —Å–µ–∫—Å-–∏–≥—Ä—É—à–∫–∏''')
#
# slut8 = Sluts(name = '–Æ–ª—è', age = 23, description = '''
# –õ—É—á—à–∏–π –≤–∞—Ä–∏–∞–Ω—Ç –¥–ª—è —Ç–µ—Ö, –∫—Ç–æ –ª—é–±–∏—Ç –±–æ–ª—å—à—É—é –≥—Ä—É–¥—å –∏ –ø–æ–∫–æ—Ä–Ω—ã–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä. –Æ–ª–µ—á—å–∫–∞ —Å–æ—á–µ—Ç–∞–µ—Ç –≤ —Å–µ–±–µ —ç—Ç–∏ –¥–≤–∞ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞, –∫–∞–∫ –Ω–∏–∫—Ç–æ –¥—Ä—É–≥–æ–πüòç
# ''', prices={'–ß–∞—Å':10900, "2 —á–∞—Å–∞":19500, '–ù–æ—á—å':51500 }, services='''–ú–ë–†, –æ–∫–æ–Ω—á–∞–Ω–∏–µ –Ω–∞ –≥—Ä—É–¥—å, –ª–µ–≥–∫–æ–µ –ø–æ–¥—á–∏–Ω–µ–Ω–∏–µ''')
#
#
# session.add(slut1)
# session.add(slut2)
# session.add(slut3)
# session.add(slut4)
# session.add(slut5)
# session.add(slut6)
# session.add(slut7)
# session.add(slut8)
# session.commit()



# def return_datetime(date_str):
#     date_format = "%d.%m.%Y"
#     return datetime.strptime(date_str, date_format)
#
# list_for_reviews = []
# def save_in_db_review(review, slut_id=8):
#
#     processed_list = review.split('\n')[2:]
#     name = processed_list[0].split(' ')[0]
#     date = processed_list[0].split(' ')[1]
#     text = processed_list[1]
#     print(name,date,text)
#     slut_review = ReviewsAboutSluts(slut_id=slut_id, name=name, text=text,date=return_datetime(date))
#     session.add(slut_review)
#     session.commit()
#
# # for i in range(1,13):
# #     exec(f'''
# # session.add(review{i})
# # session.commit()
# #     ''')
# save_in_db_review(
#
# '''üíï–û—Ç–∑—ã–≤—ã –æ –º–æ–¥–µ–ª–∏:
#
# –ê–ª–µ–∫—Å–µ–π 09.06.2019
# –°–∞–º–∞ –±–µ–∑—É–º–Ω–æ –≤–æ–∑–±—É–∂–¥–∞–µ—Ç—Å—è –∏ –∫–∞–π—Ñ—É–µ—Ç –æ—Ç –ø—Ä–æ—Ü–µ—Å—Å–∞.
# ''')
